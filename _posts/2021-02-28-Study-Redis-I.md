---
title: 如何学习 Redis (I)
published: true
categories: [program]
tags: [redis]
---

Redis 简述
> Redis 作为高性能缓存数据库的代表，本质上是一个K-V类型的内存数据库，整个数据库系统加载在内存中进行操作，定期通过异步操作将数据写入到硬盘上。因为内存上操作，Redis的性能是非常出色，每秒可以处理超过10万读写操作。此外，Redis 提供多种数据结构，且单个 value 最大限制是1GB，所以 Redis 在很多场景可以使用。Redis 的主要确定是数据库受到物理内存的限制，不能用海量数据的高性能读写，因此 Redis 使用需受到数据量的规模限制。

Redis 特点
> 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)
> 数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；
> 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
> 使用多路 I/O 复用模型，非阻塞 IO；
> 支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。
> 支持数据持久化，支持AOF和RDB两种持久化方式。

Redis 的数据类型
> String、 List、 Set、 Hash、 ZSet
> ![](/images/redis-datatype.png)   

缓存穿透
> 说明: 请求大量在缓存中不存在的Key，对后端服务造成压力，导致系统崩溃。
> 解决:
> 1. 对异常的 key 的查询结果缓存
> 2. 对大量的 key 的查询前进行过滤，限流

缓存雪崩
> 说明: 当缓存服务器重启或者大量缓存集中在某一个时间段失效，大量请求会给后端系统带来很大压力，导致系统崩溃。  
> 解决:  
> 1. 在缓存失效后，通过限流的方式控制请求
> 2. 做缓存备份，对原始缓存做一个拷贝，失效时间设置的比原始缓存要长  
> 3. 设置不同的 key 的缓存失效时间是均匀的

缓存并发竞争
> 说明: 多个客户端同时写一个 key，但顺序我们无法控制，数据就可能不对了。
> 解决: 
> 1. 使用分布式锁，同时加入数据的时间戳。同一时刻，只有抢到锁的客户端才能写入，写入时，需要比较当前数据的时间戳和缓存中数据的时间戳