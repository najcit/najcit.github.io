---
title: 如何学习 Redis (II)
published: true
categories: [program]
tags: [redis]
---

Redis 线程模型  
> 1. Redis 基于 Reactor 模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。  
> 2. 文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。  
> 3. 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。  
> 4. 虽然文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。

Redis 事务
> 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。  
> 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。
> Redis 事务的本质是通过 MULTI、 EXEC、 WATCH 等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。

Redis 缓存过期策略  
> Redis 通常有以下3种:定时过期、惰性过期和定期过期。  
> Redis 中同时使用了惰性过期和定期过期两种过期策略。
> 1. 定时过期： 每个key都会设置一个过期时间和一个定时器，到期时间就会立即清除。该策略可以立即处理过期的key,对内存友好，但会占用大量的CPU资源处理过期的key，从而影响系统的性能
> 2. 惰性过期：只有访问一个key时，才会检查key是否过期，过期则清除。该策略可以最大化的节省CPU	资源，却对内存不友好，极端情况可能出现大量的过期key没有被访问，从而不会立即清除，而占用大量内存。
> 3. 定期过期：每隔一定时间，会扫描一定的key的过期时间，并清除其中已过期的key。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。  

Redis 缓存淘汰策略  
> Redis 的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。
> 1. 全局的键空间选择性移除
	1. noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。
    2. allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。
    3. allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
> 2. 设置过期时间的键空间选择性移除
    1. volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
    2. volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
    3. volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，较早过期时间的key优先移除。

Redis 和 MySQL 的区别
> 1. MySQL 是关系型数据库，而 Redis 是 NoSQL，非关系型数据库。 
> 2. MySQL 将数据持久化到硬盘，但读取数据慢，而 Redis 将数据先存储在缓存中，读取速度快，最后按需要可以选择持久化到硬盘。
> 3. Mysql 作为持久化数据库，每次访问都要在硬盘上进行 I/O 操作。频繁访问数据库会在反复连接数据库上花费大量时间。 Redis 则会在缓存区存储大量频繁访问的数据，提高性能。

Redis 集群策略


Redis 主从复制
> Redis支持主从的模式。原则：Master会将数据同步到slave，而slave不会将数据同步到master。Slave启动时会连接master来同步数据。
> 这是一个典型的分布式读写分离模型。我们可以利用master来插入数据，slave提供检索服务。这样可以有效减少单个机器的并发访问数量